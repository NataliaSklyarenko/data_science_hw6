# -*- coding: utf-8 -*-
"""DZ_6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LfCdhsKCLO1Y0n-RFvlngn1d6mmdoetY

# Завдання 1​
Тут ви знайдете 2 файли - з двовимірним датасетом та датасетом mnist. Для кожного з них застосуйте алгоритм K-means для кластеризації. Щоб знайти оптимальну кількість кластерів, скористайтесь ліктевим методом.
"""

import pandas as pd

# Зантажуймо
df_2d = pd.read_csv('/content/data_2d.csv')
df_mnist = pd.read_csv('/content/mnist.csv')

# Перевіримо перші кілька рядків кожного датасету
display(df_2d.head())
display(df_mnist.head())

"""### K-means та ліктевий метод
Спочатку реалізуємо кластеризацію для двовимірного датасету.
"""

import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import numpy as np

# Підготовка даних
X_2d = df_2d.values

# Ліктевий метод для визначення оптимальної кількості кластерів
sse = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=0).fit(X_2d)
    sse.append(kmeans.inertia_)

# Візуалізація ліктевого методу
plt.figure(figsize=(8, 5))
plt.plot(range(1, 11), sse, marker='o')
plt.title('Ліктевий метод для двовимірного датасету')
plt.xlabel('Кількість кластерів')
plt.ylabel('SSE')
plt.show()

# Обрання оптимальної кількості кластерів
optimal_clusters_2d = 3  # Наприклад, визначили, що оптимальна кількість - 3

# Застосування K-means з оптимальною кількістю кластерів
kmeans_2d = KMeans(n_clusters=optimal_clusters_2d, random_state=0)
clusters_2d = kmeans_2d.fit_predict(X_2d)

# Візуалізація результатів кластеризації
plt.figure(figsize=(8, 5))
plt.scatter(X_2d[:, 0], X_2d[:, 1], c=clusters_2d, cmap='viridis')
plt.scatter(kmeans_2d.cluster_centers_[:, 0], kmeans_2d.cluster_centers_[:, 1], s=300, c='red')
plt.title('Кластеризація двовимірного датасету K-means')
plt.show()

"""K-means та ліктевий метод до MNIST датасету."""

# Підготовка даних
X_mnist = df_mnist.values

# Ліктевий метод для визначення оптимальної кількості кластерів
sse = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=0).fit(X_mnist)
    sse.append(kmeans.inertia_)

# Візуалізація ліктевого методу
plt.figure(figsize=(8, 5))
plt.plot(range(1, 11), sse, marker='o')
plt.title('Ліктевий метод для MNIST датасету')
plt.xlabel('Кількість кластерів')
plt.ylabel('SSE')
plt.show()

"""# Завдання 2

Візуалізуйте результат роботи кластеризації. Для випадку з mnist датасетом, вам потрібно ще скористатись алгоритмом PCA щоб зменшити розмірність вашим даних до 2-вимірного варіанту.
"""

# Обрання оптимальної кількості кластерів
optimal_clusters_mnist = 10  # Наприклад, визначили, що оптимальна кількість - 10

# Застосування K-means з оптимальною кількістю кластерів
kmeans_mnist = KMeans(n_clusters=optimal_clusters_mnist, random_state=0)
clusters_mnist = kmeans_mnist.fit_predict(X_mnist)

# Використання PCA для зменшення розмірності
from sklearn.decomposition import PCA

pca = PCA(n_components=2)
X_mnist_pca = pca.fit_transform(X_mnist)

# Візуалізація результатів кластеризації (перші дві компоненти PCA)
plt.figure(figsize=(8, 5))
plt.scatter(X_mnist_pca[:, 0], X_mnist_pca[:, 1], c=clusters_mnist, cmap='viridis')
plt.scatter(pca.transform(kmeans_mnist.cluster_centers_)[:, 0], pca.transform(kmeans_mnist.cluster_centers_)[:, 1], s=300, c='red')
plt.title('Кластеризація MNIST датасету K-means (PCA)')
plt.show()

"""Для MNIST датасету використовується алгоритм PCA для зменшення розмірності до 2 вимірів перед візуалізацією."""